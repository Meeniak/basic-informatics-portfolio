/* --- CURSOR STYLES --- */
html, body, a, input, label {
    cursor: none;
}

.custom-cursor {
    position: fixed;
    top: 0;
    left: 0;
    width: 20px;
    height: 23px;
    background-size: contain;
    background-repeat: no-repeat;
    pointer-events: none;
    transform: translate(-50%, -50%);
    z-index: 9999;
    transition: opacity 0.2s ease-in-out;
}


/* --- GENERAL BODY AND HEADER STYLES --- */
body {
    background-color: #1a1a1a;
    color: #ffffff;
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 40px;
    text-align: left;
    box-sizing: border-box; 
}

a, a:visited {
    color: #ffffff;
    text-decoration: none;
}

header {
    margin-bottom: 60px;
}

h1 {
    font-size: 8.5em;
    font-weight: 400;
    margin: 0;
    padding-top: 20px;
    padding-bottom: 20px;
    border-top: 1px solid #444;
    border-bottom: 1px solid #444;
    position: relative;
}

h1 span {
    position: relative; 
    padding-right: 40px; 
}

h1 span::after {
    content: ''; 
    position: absolute;
    background-color: #444;
    width: 1px;
    top: -30px;      
    bottom: -30px;   
    right: 0;
}

h2 {
    font-size: 1.3em;
    font-weight: 300;
    margin-top: 20px;
    max-width: 100%;
    white-space: nowrap;
}

/* --- GALLERY STYLES --- */
.gallery {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-evenly;
    gap: 30px;
}

.gallery-item {
    position: relative;
    width: 420px;
    height: 420px;
    overflow: hidden;
}

.gallery-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: filter 0.4s ease, transform 0.3s ease;
    filter: blur(5px);
}

.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 1;
    transition: background-color 0.4s ease;
}

.text {
    font-size: 2.2em;
    font-weight: bold;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s ease, transform 0.4s ease;
}

.gallery-item:hover img {
    filter: blur(0);
    transform: scale(1.05);
}

.gallery-item:hover .overlay {
    background-color: rgba(0, 0, 0, 0.4);
}

.gallery-item:hover .text {
    opacity: 1;
    transform: translateY(0);
}


/* --- SUB-PAGE HEADER STYLES --- */
.sub-page-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    border-bottom: 1px solid #444;
    margin-bottom: 50px;
}

.sub-page-header h1 {
    font-size: 4em;
    border: none;
    padding: 0;
}

.sub-page-header h1::after {
    display: none;
}

.sub-page-header a, .sub-page-header a:visited {
    color: #ccc;
    text-decoration: none;
    font-size: 1.1em;
    font-weight: 300;
    transition: color 0.3s ease;
}

.sub-page-header a:hover {
    color: white;
}


/* --- REGOLA PER L'ALLINEAMENTO DELLA HOME PAGE --- */
body.home {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}


/* --- STYLES FOR SKETCH PAGES --- */
#sketch-container {
    display: flex;
    flex-wrap: wrap; 
    gap: 30px;
    width: 100%;
    align-items: flex-start; /* Allinea gli elementi all'inizio */
    justify-content: center;
}

#canvas-wrapper {
    flex: 1 1 600px; /* Permette al wrapper di crescere ma con una base di 600px */
    max-width: 800px;
    aspect-ratio: 1 / 1; /* Mantiene il wrapper quadrato */
    border: 1px solid #444;
    display: flex;
    justify-content: center;
    align-items: center;
}

#canvas-wrapper canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: block;
}

#controls-panel {
    width: 280px;
    flex-shrink: 0;
    background-color: #1f1f1f;
    border: 1px solid #444;
    padding: 15px 20px;
    box-sizing: border-box;
    color: #ccc;
}

.control-group {
    margin-bottom: 15px;
    border-bottom: 1px solid #333;
    padding-bottom: 15px;
}
.control-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

#controls-panel h3 {
    font-size: 1.3em;
    font-weight: 400;
    margin-top: 0;
    margin-bottom: 15px;
    color: #fff;
}

#sliders {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.slider-wrapper {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
}

#controls-panel label {
    font-size: 1em;
    font-weight: 300;
    display: flex; 
    align-items: center;
}

input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 3px;
    background: #444;
    outline: none;
    opacity: 0.9;
    transition: opacity .2s;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #fff;
    border-radius: 50%;
}
input[type="range"]::-moz-range-thumb {
    width: 15px;
    height: 15px;
    background: #fff;
    border-radius: 50%;
}

#legend p {
    margin: 5px 0;
    font-size: 0.9em;
}

#legend span {
    display: inline-block;
    background-color: #333;
    color: #fff;
    padding: 2px 8px;
    border-radius: 4px;
    font-family: monospace;
    margin-right: 10px;
}
```

### 2. `masks-sketch.js` (Riscritto e Corretto)
Questo file contiene la nuova logica stabile. Ogni maschera è ora una classe separata per garantire l'isolamento e la fedeltà al tuo codice originale.

```javascript
(function() {
    let mic, fft, sensitivitySlider, maskLabel;
    let scenes = {};
    let currentScene;
    
    const maskNames = {
        1: 'Robot',
        2: 'Dragon',
        3: 'Skull',
        4: 'The Watcher',
        5: 'Forest Spirit'
    };

    window.setup = function() {
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = createCanvas(800, 800); // Canvas quadrato
        canvas.parent(canvasWrapper);
        
        mic = new p5.AudioIn();
        mic.start();
        fft = new p5.FFT(0.8, 128);
        fft.setInput(mic);

        maskLabel = select('#current-mask-label');
        sensitivitySlider = createSlider(1, 15, 7, 0.1);
        sensitivitySlider.parent('sensitivity-slider-container');
        sensitivitySlider.style('width', '100%');
        
        // Inizializza tutte le scene
        scenes = {
            1: new RobotScene(),
            2: new DragonScene(),
            3: new SkullScene(),
            4: new WatcherScene(),
            5: new ForestSpiritScene()
        };
        
        switchScene(1);
    }

    window.draw = function() {
        // Esegui il draw della scena corrente
        if (currentScene && typeof currentScene.draw === 'function') {
            currentScene.draw();
        }
    }

    function switchScene(sceneId) {
        currentScene = scenes[sceneId];
        maskLabel.html(`Current: ${maskNames[sceneId]}`);
    }

    // --- CLASSE BASE PER LE SCENE ---
    class Scene {
        constructor() {
            this.smoothedVolume = 0;
            this.easing = 0.1;
        }

        updateVolume() {
            let sensitivity = sensitivitySlider.value();
            let rawVolume = mic.getLevel() * sensitivity;
            let constrainedVolume = constrain(rawVolume, 0, 1.0); 
            this.smoothedVolume = lerp(this.smoothedVolume, constrainedVolume, this.easing);
            return this.smoothedVolume;
        }
    }
    
    // --- SCENA ROBOT (TUA CREAZIONE, FEDELE E CORRETTA) ---
    class RobotScene extends Scene {
        draw() {
            let vol = this.updateVolume();
            background(0);
            translate(width / 2, height / 2);

            let eyeHeight = map(vol, 0, 0.5, 4, 60, true);
            let visorScaleX = map(vol, 0, 0.5, 1, 1.2, true);
            let visorWidth = 280 * visorScaleX;

            noStroke(); fill(255); rect(0, -80, visorWidth, eyeHeight, 3);
            if (eyeHeight > 10) {
                let pupilSize = 60; let pupilXOffset = map(vol, 0.1, 0.5, 0, visorWidth / 2 - 40, true);
                fill(0); ellipse(-pupilXOffset, -80, pupilSize, pupilSize); ellipse(pupilXOffset, -80, pupilSize, pupilSize);
            }
            noFill(); stroke(255); strokeWeight(8); rect(0, -80, visorWidth, eyeHeight, 3);
            
            push();
            translate(0, 100);
            let mouthWidth = 280, mouthHeight = 90;
            noFill(); stroke(255); strokeWeight(6); rect(0, 0, mouthWidth, mouthHeight, 10);
            
            let spectrum = fft.analyze();
            if (spectrum && spectrum.length) {
                noStroke(); fill(255);
                let barWidth = mouthWidth / spectrum.length;
                for (let i=0; i < spectrum.length; i++) {
                    let x = map(i, 0, spectrum.length, -mouthWidth/2, mouthWidth/2);
                    let h = map(spectrum[i], 0, 255, 0, mouthHeight - 10);
                    rect(x + barWidth/2, mouthHeight/2 - h/2, barWidth * 0.8, h);
                }
            }
            pop();
        }
    }

    // --- SCENA DRAGO (TUA CREAZIONE, FEDELE E CORRETTA) ---
    class DragonScene extends Scene {
        constructor() { super(); this.n = 1; this.increment = 1; angleMode(DEGREES); }
        draw() {
            let vol = this.updateVolume();
            background(220);
            translate(width / 2 - 150, height / 2 - 200); // Centra il disegno originale
            
            let anger = map(vol, 0, 0.8, 20, 100, true);
            this.n += this.increment;
            if (this.n >= 30 || this.n <= 0) this.increment *= -1;

            if (anger > 80) {
                push(); stroke(255, this.n * 5, 0); strokeWeight(this.n); noFill();
                line(210, 270, 400 + this.n * 5, 270); pop();
            }

            let pp = map(vol, 0, 0.5, 40, 5, true);
            let arc1 = map(vol, 0, 0.5, -90, 20, true); // Movimento palpebra ridotto

            fill(0); noStroke();
            rect(100, 180, 180, 50); arc(150, 225, 100, 100, 0, 180);
            push(); fill(255, 0, 0); ellipse(150, 225, 70, 70); pop();
            ellipse(150, 225, pp, pp);
            push(); fill(255); ellipse(135, 210, 10, 10); ellipse(260, 195, 5 + vol * 40, 5 + vol * 40); pop();
            arc(150, 225, 80, 80, 240, arc1, CHORD);
            triangle(100, 155, 100, 180, 130, 180);
            triangle(200, 170, 200, 180, 220, 180); triangle(220, 170, 220, 180, 240, 180); triangle(240, 170, 240, 180, 260, 180);
            if (anger > 50) triangle(130, 155, 130, 180, 160, 180);
            if (anger > 80) triangle(160, 155, 160, 180, 190, 180);
            triangle(280, 230, 260, 245, 260, 230); triangle(250, 230, 230, 245, 230, 230); triangle(220, 230, 200, 245, 200, 230);
            
            push();
            translate(150, 235); stroke(0); strokeWeight(1.5);
            if (anger > 20) rotate(vol * 25); // Rotazione mandibola ridotta
            rect(0, 40, 80, 49); arc(80, 40, 100, 98, 0, 90); arc(0, 90, 100, 100, 180, 270);
            triangle(130, 40, 130, 25, 110, 40); triangle(100, 40, 100, 25, 80, 40); triangle(70, 40, 70, 25, 50, 40);
            pop();
        }
    }

    // --- SCENA TESCHIO (TUA CREAZIONE, FEDELE E CORRETTA) ---
    class SkullScene extends Scene {
        constructor() { super(); this.particles = []; this.rageFlash = 0; }
        draw() {
            let vol = this.updateVolume();
            background(255);
            translate(width / 2, height / 2);
            let angerLevel = map(vol, 0.1, 0.7, 0, 1, true);

            if (angerLevel > 0.95 && this.rageFlash <= 0) this.rageFlash = 15;
            let shakeAmount = map(angerLevel, 0.7, 1, 0, 20, true);
            translate(random(-shakeAmount, shakeAmount), random(-shakeAmount, shakeAmount));
            if (this.rageFlash > 0) { filter(INVERT); this.rageFlash--; }

            if (angerLevel > 0.6) {
                let pCount = map(angerLevel, 0.6, 1, 0, 5, true);
                for(let i=0; i<pCount; i++) {
                    this.particles.push(new FlameParticle(-60, -20));
                    this.particles.push(new FlameParticle(60, -20)); // Emette da entrambi i lati
                }
            }
            this.drawAngrySkull(angerLevel);
            for (let p of this.particles) { p.update(); p.show(); }
            this.particles = this.particles.filter(p => !p.isFinished());
        }
        drawAngrySkull(angerLevel) {
            fill(0); noStroke();
            let jawDrop = map(angerLevel, 0, 1, 0, 100); // Movimento ridotto
            let eyeSlant = map(angerLevel, 0, 1, 0, 30);
            let cheekFlareX = map(angerLevel, 0, 1, 0, 20);
            let crownSpike = map(angerLevel, 0, 1, 0, 30);
            beginShape(); vertex(0,-165-crownSpike); bezierVertex(-80,-170-crownSpike,-130,-120,-140-cheekFlareX,-60); bezierVertex(-150-cheekFlareX,0,-100,80,-70,110); vertex(70,110); bezierVertex(100,80,150+cheekFlareX,0,140+cheekFlareX,-60); bezierVertex(130,-120,80,-170-crownSpike,0,-165-crownSpike); endShape(CLOSE);
            this.drawLowerJaw(jawDrop);
            fill(255); this.carveTopTeeth(); // Denti
            fill(0); // FIX: Cavità oculari nere
            let eyePinch = map(angerLevel, 0.5, 1, 0, 20, true);
            beginShape(); vertex(-40,-80); bezierVertex(-80,-70-eyeSlant,-95-cheekFlareX,-20+eyePinch,-75,10+eyePinch); bezierVertex(-60,15+eyePinch,-45,0,-40,-20); endShape(CLOSE);
            beginShape(); vertex(40,-80); bezierVertex(80,-70-eyeSlant,95+cheekFlareX,-20+eyePinch,75,10+eyePinch); bezierVertex(60,15+eyePinch,45,0,40,-20); endShape(CLOSE);
            if(angerLevel>0.6){let s=map(angerLevel,0.6,1,10,45,true);for(let i=5;i>0;i--){fill(0,map(i/5,1,0,10,80));ellipse(-60,-20,s*i/5);ellipse(60,-20,s*i/5);}}
        }
        drawLowerJaw(yOffset) {
            push(); translate(0, yOffset); // FIX: Rimossa la rotazione "impazzita"
            fill(0); noStroke();
            beginShape(); vertex(-75,100); bezierVertex(-85,105,-105,140,-90,190); bezierVertex(-60,205,60,205,90,190); bezierVertex(105,140,85,105,75,100); endShape(CLOSE);
            fill(255); this.carveLowerTeeth(); pop();
        }
        carveTopTeeth(){for(let i=0;i<8;i++){let t=i/7,x=lerp(-70,70,t),w=140/8*.9,h=15-pow(abs(t-.5)*2,2)*8;beginShape();vertex(x-w/2,110);vertex(x+w/2,110);vertex(x,110-h);endShape(CLOSE);}}
        carveLowerTeeth(){for(let i=0;i<7;i++){let t=i/6,x=lerp(-60,60,t),w=120/7*.9,h=15-pow(abs(t-.5)*2,2)*10;beginShape();vertex(x-w/2,100);vertex(x+w/2,100);vertex(x,100+h);endShape(CLOSE);}}
    }

    // --- NUOVA MASCHERA 4 ---
    class WatcherScene extends Scene {
        draw() {
            let vol = this.updateVolume();
            background(24,24,24); translate(width/2, height/2);
            let focus = map(vol, 0, 1, 0, 120, true);
            let coreBrightness = map(vol, 0, 1, 50, 255, true);
            stroke(255); noFill(); strokeWeight(3);
            // Occhi
            ellipse(-150, 0, 150, 150 - focus);
            ellipse(150, 0, 150, 150 - focus);
            // Core
            fill(255, coreBrightness); noStroke();
            ellipse(0, 0, 80, 80);
            // Struttura
            noFill(); stroke(255, 150); strokeWeight(2);
            line(-225, 0, -75, 0); line(225, 0, 75, 0);
            line(0, -40, 0, 40);
        }
    }
    
    // --- MASCHERA 5 (CORRETTA) ---
    class ForestSpiritScene extends Scene {
        draw() {
            let vol = this.updateVolume();
            background(24,24,24); translate(width/2, height/2);
            let headTilt = map(vol, 0, 1, 0, 20, true);
            let leafGrow = map(vol, 0, 1, 0, 80, true);
            stroke(255); strokeWeight(4); fill(24, 24, 24);
            push();
            rotate(-headTilt); // FIX: Rimossa la rotazione incontrollata
            ellipse(0, 0, 200, 250);
            fill(255); ellipse(-50, -30, 50, 70); ellipse(50, -30, 50, 70);
            noFill();
            beginShape();vertex(-100,0);bezierVertex(-150,-50,-150-leafGrow,-100,-100,-150);endShape();
            beginShape();vertex(100,0);bezierVertex(150,-50,150+leafGrow,-100,100,-150);endShape();
            pop();
        }
    }
    
    // Helper per il teschio
    class FlameParticle {
        constructor(x,y){this.pos=createVector(x,y);this.vel=p5.Vector.random2D().mult(random(2,5));this.lifespan=255;}
        isFinished(){return this.lifespan<=0;}
        update(){this.pos.add(this.vel);this.lifespan-=5;}
        show(){noStroke();fill(255,this.lifespan);ellipse(this.pos.x,this.pos.y,8);}
    }

    window.keyPressed = function() {
        if (key >= '1' && key <= '5') switchScene(parseInt(key));
        if (key.toLowerCase() === 's') saveCanvas('my-mask', 'png');
    }
})();
